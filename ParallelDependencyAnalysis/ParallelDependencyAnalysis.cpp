///////////////////////////////////////////////////////////////////////////////
// ParallelDependencyAnalysis.cpp - Performs dependency analysis in 2 passes //
// ver 1.0                                                                   //
// -----------------------------------------------------------------------   //
// Language:    Visual C++, Visual Studio 2015                               //
// Platform:    ThinkPad L440, Core i7-4712MQ                                //
// Author:      Alok Arya                                                    //
//              (315) 728-0088, alarya@syr.edu                               //
///////////////////////////////////////////////////////////////////////////////
 
#include "ParallelDependencyAnalysis.h"
#include "../Parser/ConfigureParser.h"
#include "../SemiExp/SemiExp.h"
#include "../Tokenizer/Tokenizer.h"
#include "../Parser/ActionsAndRules.h"
#include "../ThreadPool/QueuedWorkItems.h"
#include  "../Tasks//AsynFunction.h"
#include "../FileMgr/FileMgr.h"
#include "../TypeAnalysis/TypeAnalysis.h"
#include <vector>
#include <iomanip>

using namespace Analyzer;
using namespace File;


//-----------Constructor--------------------------------//
ParallelDependencyAnalysis::ParallelDependencyAnalysis()
{

}

//------------Destructor--------------------------------//
ParallelDependencyAnalysis::~ParallelDependencyAnalysis()
{

}

void ParallelDependencyAnalysis::DependencyAnalysis(std::string dir, std::string pattern)
{
	Pass1(dir, pattern);     //Pass1: calls Pass2 when done
}

//----------print the type table generated by parsing--------------//
void ParallelDependencyAnalysis::printTypeTable(std::vector<Type>* pTypeTable)
{
	std::cout << "\n\n Merged Type Table";
	std::cout << "\n--------------------------------------------------------------------------------------------------------------------------------------\n";
	std::cout << "Type" << std::setw(30) << "Name" << std::setw(30) << "Namespace" << std::setw(60) << "File\n";
	std::cout << "----------------------------------------------------------------------------------------------------------------------------------------\n";
	for each (auto Type in *pTypeTable)
	{
		std::cout << Type.type << std::setw(30) << Type.name << std::setw(30);
		std::string _ns = "";
		for each(auto ns in Type.namespaces)
		{
			_ns += ns + "::";
		}
		std::cout << _ns.substr(0, _ns.size() - 2);
		std::cout << std::setw(100) << Type.file << "\n";
	}
}


//--------------function to get all files and enque them for further processing--------//
void enqueueFiles(ProcessWorkItem<std::string>& filesProcessor,std::string dir, std::string pattern)
{
	FileMgr fileMgr;
	std::vector<string> files = fileMgr.getAllFiles(dir, pattern);
	for each(auto file in files)
	{
		cout << "\nFound file: "<< file << "..Enqueued for analysis\n";
		WorkItem<std::string>* wi = new WorkItem<std::string>();
		*wi = 	[=]() {
			return file;
		};

		filesProcessor.doWork(wi);
	}
}

//------------return the result of type analysis of a file and enque the result---------------//
void typeAnalysis(ProcessWorkItem <std::vector<Type>>& typeAnalysisProcessor, std::string file)
{
	TypeAnalysis typeAnalyzer;
	std::vector<Type> partialTypeTable = typeAnalyzer.doAnalysis(file);
	
	WorkItem <std::vector<Type>>* wi = new WorkItem<std::vector<Type>>();
	*wi = [=]() {
		return partialTypeTable;	
	};

	typeAnalysisProcessor.doWork(wi);
}

//--------deque the files found and start thread to do type analysis on it -------------------//
void dequeueFiles(ProcessWorkItem<std::string>& filesProcessor, ProcessWorkItem <std::vector<Type>>& typeAnalysisProcessor)
{
	std::vector<std::thread> typeAnalysisThreads;

	while (filesProcessor.resultsQueueSize() != 0)
	{
		std::string file = filesProcessor.result();

		std::cout << "\nStarting type Analysis on: " << file << "\n";

		typeAnalysisThreads.push_back(std::thread(typeAnalysis, std::ref(typeAnalysisProcessor), file)); //start a thread to start building partial type tables
	}
	
	//wait for all type analysis threads to finish 
	for (auto& thread : typeAnalysisThreads)
			thread.join();
}

//-------runs on a single thread to deque partial Type tables and merge them----------------------------//
void merge(ProcessWorkItem <std::vector<Type>>& typeAnalysisProcessor, std::vector<Type>& mergedTypeTable)
{
	
	std::cout << "\n Merging partial type tables........................ \n";
	
	while (typeAnalysisProcessor.resultsQueueSize() != 0)
	{
		std::vector<Type> partialTypeTable = typeAnalysisProcessor.result();
		for each (auto type in partialTypeTable)
			mergedTypeTable.push_back(type);
	}
}


//---------------------Builds Merged Type Table from type analysis of each file ---------//
void ParallelDependencyAnalysis::Pass1(std::string dir, std::string pattern)
{
	
	ProcessWorkItem<std::string> filesProcessor;
	filesProcessor.start();

	ProcessWorkItem<std::vector<Type>> typeAnalysisProcessor;
	typeAnalysisProcessor.start();

	std::vector<Type> mergedTypeTable;
	
	std::thread findFiles(enqueueFiles,std::ref(filesProcessor),dir,pattern);   //thread starts enqueing files found	
	findFiles.join();

	std::thread startTypeAnalysis(dequeueFiles, std::ref(filesProcessor),std::ref(typeAnalysisProcessor));  //deque files found and start parallel analysis on them analysis 
	startTypeAnalysis.join();

	//done with processing files & type analysis for each of them
	filesProcessor.doWork(nullptr);		
	filesProcessor.wait();	
	std::cout << ": done with finding files \n";
	typeAnalysisProcessor.doWork(nullptr);
	typeAnalysisProcessor.wait();
	std::cout << ": done with type analysis on files \n";

	//need to start a thread to merge results queue of typeAnalysisProcessor here
	std::thread mergePartialTypeTables(merge, std::ref(typeAnalysisProcessor), std::ref(mergedTypeTable));
	mergePartialTypeTables.join();

	//now we have mergedTypeTable
	printTypeTable(&mergedTypeTable);

	//proceed to pass 2
}

void ParallelDependencyAnalysis::Pass2()
{

}


#ifdef TEST_PARALLELDEPANALYSIS 
int main(int argc, char* argv[])
{
	ParallelDependencyAnalysis pDepAnal;
	pDepAnal.DependencyAnalysis("../../root","*.h");

}
#endif 
