///////////////////////////////////////////////////////////////////////////////
// ParallelDependencyAnalysis.cpp - Performs dependency analysis in 2 passes //
// ver 1.0                                                                   //
// -----------------------------------------------------------------------   //
// Language:    Visual C++, Visual Studio 2015                               //
// Platform:    ThinkPad L440, Core i7-4712MQ                                //
// Author:      Alok Arya                                                    //
//              (315) 728-0088, alarya@syr.edu                               //
///////////////////////////////////////////////////////////////////////////////
 
#include "ParallelDependencyAnalysis.h"
#include "../Parser/ConfigureParser.h"
#include "../Parser/ActionsAndRules.h"
#include "../ThreadPool/QueuedWorkItems.h"
#include "../FileMgr/FileMgr.h"
#include "../TypeAnalysis/TypeAnalysis.h"
#include "../DependencyAnalysis/DependencyAnalysis.h"
#include <vector>
#include <iomanip>

using namespace Analyzer;
using namespace File;

struct DepResult
{
	 map<string, vector<string>> result;
};

//-----------Constructor-----------------------------------------------------------------//
ParallelDependencyAnalysis::ParallelDependencyAnalysis()
{

}

//------------Destructor------------------------------------------------------------------//
ParallelDependencyAnalysis::~ParallelDependencyAnalysis()
{

}

void ParallelDependencyAnalysis::DependencyAnalysis(FileSpec filespec)
{
	Pass1(filespec);     //Pass1: calls Pass2 when done
}

//--------------print the type table generated by parsing----------------------------------//
void ParallelDependencyAnalysis::printTypeTable(vector<Type>* pTypeTable)
{
	std::cout << "\n\n Merged Type Table";
	std::cout << "\n--------------------------------------------------------------------------------------------------------------------------------------\n";
	std::cout << "Type" << std::setw(30) << "Name" << std::setw(30) << "Namespace" << std::setw(60) << "File\n";
	std::cout << "----------------------------------------------------------------------------------------------------------------------------------------\n";
	for each (auto Type in *pTypeTable)
	{
		std::cout << Type.type << std::setw(30) << Type.name << std::setw(30);
		std::string _ns = "";
		for each(auto ns in Type.namespaces)
		{
			_ns += ns + "::";
		}
		std::cout << _ns.substr(0, _ns.size() - 2);
		std::cout << std::setw(100) << Type.file << "\n";
	}
}

//--------------function to get all files and enque them for further processing------------//
void enqueueFiles(ThreadPool<string>& fp,FileSpec filespec)
{
	FileMgr fileMgr;
	std::vector<string> files = fileMgr.getAllFilesForPatterns(filespec.dir, filespec.patterns);
	for each(auto file in files)
	{
		cout << "\nFound file: "<< file << "..Enqueued for analysis\n";
		WorkItem<std::string>* wi = new WorkItem<std::string>();
		*wi = 	[=]() {
			return file;
		};

		fp.doWork(wi);
	}
}

//------------enqueue work items on the work queue of typeAnalysiProc----------------------//
void typeAnalysis(ThreadPool <vector<Type>>& tp, string file)
{	
	WorkItem <std::vector<Type>>* wi = new WorkItem<std::vector<Type>>();
	*wi = [=]() {
		std::cout << "\nStarting type Analysis on: " << file << " on thread: "<< std::this_thread::get_id() << "\n";
		TypeAnalysis typeAnalyzer;
		std::vector<Type> partialTypeTable = typeAnalyzer.doAnalysis(file);
		return partialTypeTable;	
	};

	tp.doWork(wi);
}

//--------deque the files found and calls type analysis to enQ type analysis work items----------------//
void dequeueFiles(ThreadPool<string>& fp, ThreadPool <vector<Type>>& tp)
{
	while (fp.resultsQueueSize() != 0)
	{
		std::string file = fp.result();
				
		typeAnalysis(std::ref(tp), file); //start a thread to start building partial type tables
	}
}

//-------runs on a single thread to deque partial Type tables and merge them---------------//
void merge(ThreadPool <vector<Type>>& tp, vector<Type>& mergedTT)
{
	
	std::cout << "\n Merging partial type tables........................ \n";
	
	while (tp.resultsQueueSize() != 0)
	{
		std::vector<Type> partialTypeTable = tp.result();
		for each (auto type in partialTypeTable)
			mergedTT.push_back(type);
	}
}

//---------------------Builds Merged Type Table from type analysis of each file -----------//
void ParallelDependencyAnalysis::Pass1(FileSpec filespec)
{
	
	ThreadPool<std::string> filesProc;
	filesProc.start();

	ThreadPool<std::vector<Type>> typeAnalProc;
	typeAnalProc.start();

	std::vector<Type> mergedTypeTable;
	
	std::thread findFiles(enqueueFiles,std::ref(filesProc),filespec);   //thread starts enqueing files found	
	findFiles.join();

	std::thread startTypeAnalysis(dequeueFiles, std::ref(filesProc),std::ref(typeAnalProc));  //deque files found and start parallel analysis on them analysis 
	startTypeAnalysis.join();

	//done with processing files & type analysis for each of them
	filesProc.doWork(nullptr);		
	filesProc.doWork(nullptr);
	filesProc.doWork(nullptr);
	filesProc.doWork(nullptr);
	filesProc.wait();	
	std::cout << "\ndone with finding files \n";
	typeAnalProc.doWork(nullptr);
	typeAnalProc.doWork(nullptr);
	typeAnalProc.doWork(nullptr);
	typeAnalProc.doWork(nullptr);
	typeAnalProc.wait();
	std::cout << "\ndone with type analysis on files \n";

	//need to start a thread to merge results queue of typeAnalysisProcessor here
	std::thread mergePartialTypeTables(merge, std::ref(typeAnalProc), std::ref(mergedTypeTable));
	mergePartialTypeTables.join();

	//now we have mergedTypeTable
	printTypeTable(&mergedTypeTable);

	//proceed to pass 2
	Pass2(mergedTypeTable, filespec);
}

//------------enques work items to dep analysis proc ---------------------------------------------//
void depAnalysis(ThreadPool<DepResult>& dp, string f,vector<Type>& TT)
{	
	WorkItem <DepResult>* wi = new WorkItem<DepResult>();
	*wi = [=]() {
		std::cout << "\nStarting Dep Analysis on: " << f << " on thread: " << std::this_thread::get_id() << "\n";
		DependencyAnalysis dependencyAnalyzer;
		DepResult partialDependencies;
		partialDependencies.result = dependencyAnalyzer.doAnalysis(f, TT);
		return partialDependencies;
	};
	dp.doWork(wi);
}

//--------deque the files found and calls method to enque dep analysis work item on depanalysis proc -----//
void dQFilesForDepAnalysis(ThreadPool<string>& fp, ThreadPool<DepResult>& dp, vector<Type>& TT)
{

	while (fp.resultsQueueSize() != 0)
	{
		std::string file = fp.result();

		depAnalysis(std::ref(dp), file,std::ref(TT)); //call method to enqueue dep analysis work items to depAnalProc
	}

}

//----------------------merge the dependency results --------------------------------------//
void mergeDeps(ThreadPool <DepResult>& depAnalysisProc, DepResult& mergedDepResult)
{
	std::cout << "\n Merging Dependency Results ........................ \n";

	while (depAnalysisProc.resultsQueueSize() != 0)
	{
		DepResult partialDependencies = depAnalysisProc.result();
		for each (auto dep in partialDependencies.result)
		{
			mergedDepResult.result[dep.first] = dep.second;
		}
	}
}

//-----------------Pass 2 -----------------------------------------------------------------//
void ParallelDependencyAnalysis::Pass2(TypeTable mergedTT, FileSpec filespec)
{
	cout << "\n\n\nStarting Pass 2";
	cout << "\n=======================================================================================================================\n";
	ThreadPool<string> filesProc;
	filesProc.start();

	ThreadPool<DepResult> depAnalProc;
	depAnalProc.start();

	//merged dependencies
	DepResult mergedDepResult;

	std::thread findFiles(enqueueFiles, std::ref(filesProc), filespec);   //thread starts enqueing files found	
	findFiles.join();

	std::thread startDepAnalysis(dQFilesForDepAnalysis, ref(filesProc), ref(depAnalProc), ref(mergedTT));  //deque files found and start parallel analysis on them 
	startDepAnalysis.join();

	//Enqueued all files: send signal for child threads to quit
	filesProc.doWork(nullptr);
	filesProc.doWork(nullptr);
	filesProc.doWork(nullptr);
	filesProc.doWork(nullptr);
	filesProc.wait();
	std::cout << "\ndone with finding files \n";

	//Enqueued all dep analysis work items: send signal for child threads to quit
	depAnalProc.doWork(nullptr);
	depAnalProc.doWork(nullptr);
	depAnalProc.doWork(nullptr);
	depAnalProc.doWork(nullptr);
	depAnalProc.wait();
	std::cout << "\ndone with dep analysis on files \n";

	//need to start a thread to merge results queue of typeAnalysisProcessor here
	std::thread mergePartialDependencies(mergeDeps, std::ref(depAnalProc), std::ref(mergedDepResult));
	mergePartialDependencies.join();

	//display dependencies
	std::cout << "\n\n\n DEPENDENCY RESULT \n" << "================================================================\n";
	for (auto file : mergedDepResult.result)
	{
		std::cout << "\nFile: " << file.first << "\n";
		std::cout << "\tDepends on:-\n";
		auto dependsOnFiles = file.second;
		for (auto dependsOnfile : dependsOnFiles)
		{
			std::cout << "\t" << dependsOnfile << "\n";
		}
	}
}


#ifdef TEST_PARALLELDEPANALYSIS 
int main(int argc, char* argv[])
{
	ParallelDependencyAnalysis pDepAnal;

	std::vector<string> patterns;
	patterns.push_back("*.h");
	patterns.push_back("*.cpp");
	FileSpec fp;
	fp.dir = "../../root";
	fp.patterns = patterns;

	pDepAnal.DependencyAnalysis(fp);

}
#endif 
