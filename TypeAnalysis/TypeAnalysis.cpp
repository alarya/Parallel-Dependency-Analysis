/////////////////////////////////////////////////////////////////////////////
// ParallelDependencyAnalysis.h - Performs dependency analysis in 2 passes //
// ver 1.0                                                                 //
// ----------------------------------------------------------------------- //
// Language:    Visual C++, Visual Studio 2015                             //
// Platform:    ThinkPad L440, Core i7-4712MQ                              //
// Author:      Alok Arya                                                  //
//              (315) 728-0088, alarya@syr.edu                             //
/////////////////////////////////////////////////////////////////////////////

#include "../Parser/Parser.h"
#include "../Parser/ConfigureParser.h"
#include "TypeAnalysis.h"
#include "../Parser/ActionsAndRules.h"
#include <iostream>
#include <vector>
#include <mutex>

using namespace Analyzer;

//--static mutex: used to sync outputting partial type tables to console-------------------//
std::mutex TypeAnalysis::mtx_;

//----------print the type table generated by parsing--------------//
void TypeAnalysis::printTypeTable(std::vector<Type>* pTypeTable,std::string file)
{
	std::lock_guard<std::mutex> l(mtx_);
	std::cout << "\nPartial Type Table for: " << file << " generated...\n";

	std::cout << "\n----------------------------------------------------------------------------------------------------------------------\n";
	std::cout << "Type \t\t\t Name \t\t\t Namespace \t\t\t File \n";
	std::cout << "------------------------------------------------------------------------------------------------------------------------\n";
	for each (auto Type in *pTypeTable)
	{
		std::cout << Type.type << "\t\t\t" << Type.name << "\t\t\t";
		std::string _ns = "";
		for each(auto ns in Type.namespaces)
		{
			_ns += ns + "::";
		}
		std::cout << _ns.substr(0, _ns.size() - 2);
		std::cout << "\t\t\t" << Type.file << "\n";
	}
}

//-------------------does analysis on a single file and returns it's type table---------//
std::vector<Type> TypeAnalysis::doAnalysis(std::string file)
{
	ConfigParserForTypeTable builder;
	Parser* _parser;

	_parser = builder.Build();
	if (builder.Attach(file, true))
	{
		//std::cout << "\n\n\n\nFile: " << fileName << "\n";
		while (_parser->next())
		{
			_parser->parse();
		}
	}
	else
	{
		std::cout << "\n Could not attach file to parser \n";
	}
	std::vector<Type>* pTypeTable = builder.TypeTable();	

	printTypeTable(pTypeTable,file);

	return *pTypeTable;
}

#ifdef TEST_TYPEANALYSIS
int main(int argc, char* argv[])
{
	TypeAnalysis typeAnalysis;
	typeAnalysis.doAnalysis("../../Parser/ActionsAndRules.h");
}
#endif // TEST_TYPEANALYSIS
